package misc.bot.mcts;

import java.util.ArrayList;
import java.util.List;

import misc.bot.buildPlanning.BuildNode;
import misc.bot.moves.BotMove;
import misc.simulator.DiceRoller;
import misc.utils.ReducedGame;
import soc.game.SOCGame;
import soc.game.SOCPlayer;

public class ChanceNode extends TreeNode {

	public ChanceNode(TreeNode parent, BuildNode node) {
		super(TreeNode.CHANCE_NODE, parent, node);
		
		//Chance nodes advance on the turn of the player by one - the next player is rolling the dice.
		if(parent.getPlayerTurn()!=3){
			this.playerTurn = parent.getPlayerTurn() + 1;
		}else{
			this.playerTurn = 0;
		}

		for(int i=0;i<=13;i++){
			children.add(i, null);
		}
	}

	/**
	 * Selection method for the chance nodes. In the chance nodes choices are
	 * made at random based on the dice rolls. This means that a more likely
	 * dice roll will be simulated more often.
	 * 
	 * @return The Tree node we are selecting
	 */
	@Override
	public TreeNode selectNextNode() {
		int roll = DiceRoller.rollDice();
		
		//Check if we have visited the node generated by that number before.
		
		//If we haven't then add it to the list and gen child nodes for it..
		if(children.get(roll) == null){
			ReducedGame gameCopy = buildNode.getReducedGame();
			if(roll!=7){
				gameCopy.assignResources(roll);
			}else{
				//gameCopy.handlePlayerDiscard(discarded, player);
			}
			gameCopy.setOurPlayerNumber(playerTurn);
			SOCGame refGame = buildNode.getGame();
			SOCPlayer ourPlayer = refGame.getPlayer(playerTurn);
			BuildNode node = new BuildNode(gameCopy, null, null, ourPlayer, refGame);
			DecisionNode child =  new DecisionNode(this, node);
			child.getBuildNode().generateChildNodes();
			List<BuildNode> childExpansions = new ArrayList<BuildNode>();
			child.getBuildNode().gatherChildren(child.getBuildNode(), childExpansions);
			child.addUnexploredChildren(TreeNode.CHANCE_NODE, childExpansions);
			children.add(roll, child);
		}
		
		return children.get(roll).selectNextNode();
	}

}
